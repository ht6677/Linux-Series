# 线程模型

线程模型解决的问题，是如何高效的利用多个物理核，进行工作任务的调度，使得系统能够有更高有效的吞吐，更加低的延迟。而不是把时间花在大量的比如系统层面的上下文切换等工作。在 Linux 进程与线程的章节中，我们讨论了 Linux 的进程与线程模型，而在网络 IO 中最简单的就是连接独占模型：也就是一个连接进来请求后，独占一个线程（进程）进行处理。（无论其中中间在做什么事情，比如调用第三方的服务，等待过程中也是独占着整个线程），比如传统的tomcat servlet就是这么干的。而我们现在实际应用中常用的是 Reactor模型，单线程Reactor模型：使用单个线程处理所有连接上的请求，使用epoll-wait 方式，实现事件多路复用机制。典型比如Redis，适用于简单比如小数据的内存数据的获取。每一个回调逻辑都比较简单。以及多线程Reactor模型，是多个线程/进程Accept同一个连接上的请求。

## Reactor 模型

- 单线程模型

所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程需要处理客户端的 TCP 连接，同时读取客户端 Socket 的请求或者应答消息以及向客户端发送请求或者应答消息。如下图：

![](https://i.postimg.cc/cLws0kS8/1fdcd36e76359339539a507278f566d7.png)

由于采用的是非阻塞的 IO，所有 IO 操作都不会导致阻塞，从理论上来说，一个线程可以独立处理所有的 IO 相关操作，处理流程如下:

![](https://i.postimg.cc/zfNqBwz2/65cdba67cfcee3302b88d114e2fd5baf.png)

可以看出，单线程模型只适用并发量比较小的应用场景。当一个 NIO 线程同时处理上万个连接时，处理速度会变慢，会导致大量的客户端连接超时，超时之后如果进行重发，更加会加重了 NIO 线程的负载，最终会有大量的消息积压和处理超时，NIO 线程会成为系统的瓶颈。

- 多线程模型

多线程模型与单线程模型最大的区别是有专门的一组 NIO 线程处理 IO 操作，一般使用线程池的方式实现。一个 NIO 线程同时处理多条连接，一个连接只能属于 1 个 NIO 线程，这样能够防止并发操作问题。

![](https://i.postimg.cc/s2JsZB1j/fbd2af5606580061718cb69254f95a71.png)

- 主从多线程模型

服务端用于接收客户端连接的不是 1 个单独的 NIO 线程了，而是采用独立的 NIO 线程池。Acceptor 接收 TCP 连接请求处理完成之后，将创建新的 SocketChannel 注册到处理连接的 IO 线程池中的某个 IO 线程上，有它去处理 IO 读写以及编解码的工作。Acceptor 只用于客户端登录、握手以及认证，一旦连接成功之后，将链路注册到线程池的 IO 线程上。

![](https://i.postimg.cc/SsNqLyzW/e774d586cd02cf2d4e7adba4b8300eac.png)

## 编程模型与协程

在进程，线程与协程的对比中我们讨论过协程的优劣，在上面讨论的多种线程模型中，我们仍然面临着一个问题，就是避免在如上回调逻辑中调用block的逻辑否则一个事件处理Block，就是将整个线程反应堆都给Block了。比如Nginx针对磁盘IO推出多线程支持，在Nginx中磁盘IO层面的请求，不直接inplace在对应的反应堆中进行，而是将磁盘IO的阶段委派给专门的单独的线程池进行。（比如proxy_temp_file从后端拉数据缓存在本地磁盘消费的场景）

总结来说连接独占模型，主要依赖多开线程的方式来提供服务端的吞吐。但是多开线程势必带来的问题就是系统层面的开销比较大（contex-switch、cache-bounding等等），对于高性能场景典型就不太适用。

而从编程模式上，异步的编程模式总归来说是非常复杂的，比如1个请求需要请求N个模块完成的情况下，如果使用异步模式，那简直就是太不直观，写出正确逻辑的代价会非常大，测试也非常困难。

作为专门领域的实现使用Reactor模式没有太大的问题。但是如果是在RPC场景下，对接RPC后端的是复杂的业务逻辑情况下，要基于Reactor来玩真的就太难了，从业务层面最希望的就是同步方式的编程模型。所以从实现通用的RPC框架层面来说，基于这样的线程模型的同时，再上层提供简洁的并发编程组件，就显得格外重要。

那从实现层面，就需要在block（比如网络调用）的情况下，保留当前task执行的上线文(栈、寄存器、signal等)，然后切换到别的可以执行的task上。在task具备执行条件的时候将当前执行线程的context替换为为对应的task中保存的上下文，从而实现执行逻辑的切换。

这种实现模式一般来说称为用户态线程、协程（coroutine），

这个方面实现最彻底的是golang语言，直接在语言runtime层面把这个问题搞定。brpc框架则设计了bthread和相关的组件来实现。从调度模式来看，用户态线程主要分几大类

N：1用户态线程库模型: N个用户态下线程对应1个native 的thread，如腾讯开源的libco等。
M：N 用户态线程库模型：典型如go语言的goroutine、brpc的 bthread、开源实现libgo。并且支持work-steal的调度模型来避免长尾效应。
